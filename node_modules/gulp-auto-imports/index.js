'use strict';
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./index.types"), exports);
__exportStar(require("./createAutoImportTask"), exports);
/*
  Loosely based on the code used in Gulp Concat
  https://github.com/gulp-community/gulp-concat/blob/master/index.js
*/
// npm
var through = require('through2');
var fileExists = require('file-exists');
var c = require('chalk');
// helpers
var err = require('./core/helpers/err');
var log = require('./core/helpers/log');
var join = require('./core/helpers/join');
var get_relative_path = require('./core/content-generators/get_relative_path');
var read_file = require('./core/file_manipulation/read_file');
var generate_content = require('./core/content-generators/generate_content');
var create_file = require('./core/file_manipulation/create_file');
var order_content = require('./core/content-generators/order_content');
var presets = require('./core/content-generators/preset-settings');
var dest_error = require('./core/error-messages/dest');
var format_error = require('./core/error-messages/format');
var fileName_error = require('./core/error-messages/fileName');
var autoImports = function (opt) {
    if (opt.preset) {
        opt = Object.assign({}, presets[opt.preset], opt);
    }
    err(!opt.fileName, fileName_error);
    err(!opt.format, format_error);
    err(!opt.dest, dest_error);
    var lastFile;
    var latestMod;
    var generatedFilePath = join([opt.dest, opt.fileName]);
    var relativePaths = [];
    function bufferContents(file, _enc, done) {
        // ignore empty files
        if (file.isNull()) {
            return done();
        }
        // gulp-auto-imports doesn't support streams
        err(file.isStream(), 'Streaming is not supported');
        // set latest file if not already set,
        // or if the current file was modified more recently.
        if (!latestMod || (file.stat && file.stat.mtime > latestMod)) {
            lastFile = file;
            latestMod = file.stat && file.stat.mtime;
        }
        relativePaths.push(get_relative_path(file, opt.dest));
        done();
    }
    function endStream(done) {
        var _this = this;
        // no files passed in, no file goes out
        if (!lastFile) {
            return done();
        }
        var new_content = function () {
            return generate_content({ pathsArray: relativePaths, opt: opt });
        };
        var generate_file = function (content) {
            var newFile = create_file(lastFile, opt, content);
            log("Generated " + c.magenta(join([opt.dest, c.yellow(opt.fileName)])));
            _this.push(newFile);
            done();
        };
        fileExists(generatedFilePath, function (error, exists) {
            err(error, error);
            if (exists) {
                read_file(generatedFilePath).then(function (oldContent) {
                    var orderedContent = opt.retainOrder
                        ? order_content({ oldContent: oldContent, newPaths: relativePaths, opt: opt })
                        : new_content();
                    if (orderedContent === oldContent) {
                        //Skip file generation
                        done();
                    }
                    else {
                        generate_file(orderedContent);
                    }
                });
            }
            else {
                generate_file(new_content());
            }
        });
    }
    return through.obj(bufferContents, endStream);
};
exports.default = autoImports;
